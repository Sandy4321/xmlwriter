'''
This takes Python __doc__ strings and writes them out in C++ in a way suitable
for pybind11.

Usage::

    python pydoc2cppdoc.py <module>

This will import the module, extract all the documentation strings and write
a C++ file of string literals to stdout. These literals can be used in your
pybind11 file.

Here is a very simple example:

Suppose you have a module 'Example.py' that looks like this::

    """
    Example module documentation.
    """
    class Example:
        """Example class documentation"""
        def __init__(self, *args, **kwargs):
            """Construct an Example."""
            pass

If you run::

    python pydoc2cppdoc.py Example.py

It will produce something like this::

    // Auto generated documentation strings
    //       Module: Example
    //  Module path: /Users/paulross/Documents/workspace/git/src/paulross/xmlwriter/xmlwriter/py/xmlwriter/Example.py
    // Generated by: pydoc2cppdoc.py
    // Generated on: Mon Mar 12 19:24:51 2018
    
    const char *DOCSTRING_Example = R"doc_from_python(
    Example module documentation.
    
    )doc_from_python";
    
    const char *DOCSTRING_Example_Example = R"doc_from_python(Example class documentation
    )doc_from_python";
    
    const char *DOCSTRING_Example_Example___init__ = R"doc_from_python(Construct an Example.
    )doc_from_python";

Save this as a file such as Example_docs.h then in your pybind11 file pull in the docstrings::

    PYBIND11_MODULE(cXmlWrite, m) {
        m.doc() = DOCSTRING_Example;
        
        py::class_<Example>(m, "Example", DOCSTRING_Example_Example)
            .def(py::init<>(),
                 DOCSTRING_Example_Example___init__)

For a bigger example run this on the accompanying ExampleDocstring.py thus::

    python pydoc2cppdoc.py ExampleDocstrings.py


Created on 23 Feb 2018

@author: paulross
'''
import argparse
import builtins
import datetime
import importlib
import inspect
# import logging
import os
import re
import sys

#: Builtin types to ignore. Retain type type to get our class docstrings.
builtins_special = [_b[1] for _b in inspect.getmembers(builtins) if _b[1] != type]
#: Unique delimiter for string literal names.
cpp_str_delim = 'doc_from_python'
#: Detect special method names.
RE_MAGIC_METH = re.compile(r'__(.+?)__')

#: decl is for header files, defn is for .c/.cpp files
output_styles = ('decl', 'defn')

DOCSTRING_VARIBLE_PREFIX = 'DOCSTRING'

def print_doc(doc_str, style, *args):
    """
    Print out the documentation string as a string literal named from args.
    """
    assert style in output_styles, '{!r:s} not in {!r:s}'.format(style, output_styles)
    if style == 'decl':
        print('extern const char *{}_{};'.format(DOCSTRING_VARIBLE_PREFIX, '_'.join(args)))
    elif style == 'defn':
        print('const char *{}_{} = R"{}({}'.format(DOCSTRING_VARIBLE_PREFIX,
                                                   '_'.join(args),
                                                   cpp_str_delim,
                                                   doc_str))
        print('){}";'.format(cpp_str_delim))
        print()
    else:
        assert(0)


def get_doc(obj):
    """
    Returns the documentation or None. Ignore imported modules.
    """
    if type(obj) not in builtins_special and str(type(obj)) != "<class 'module'>":
        return getattr(obj, '__doc__', None) 


def print_member_doc(name, obj, style):
    """
    Recursively print documentation strings.
    Returns the number of strings written out.
    """
    assert style in output_styles, '{!r:s} not in {!r:s}'.format(style, output_styles)
    num = 0
    for member_name, member_obj in sorted(inspect.getmembers(obj)):
        doc = get_doc(member_obj)
        if doc is not None:
            print_doc(doc, style, name, member_name)
            num += 1
            if RE_MAGIC_METH.match(member_name) is None:
                num += print_member_doc(
                    '{}_{}'.format(name, member_name), member_obj, style
                )
    return num


def main():
    """
    Extracts documentation strings from the Python module given as an
    argument and writes them as C++ literal strings to stdout.
    """
    parser = argparse.ArgumentParser(
        description='Extracts documentation strings from a module and writes them out suitable for C++',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(type=str, dest="module", help="Module to import.")
#     parser.add_argument(
#             "-l", "--loglevel",
#             type=int,
#             dest="loglevel",
#             default=30,
#             help="Log Level (debug=10, info=20, warning=30, error=40, critical=50)" \
#             " [default: %(default)s]"
#         )
#     parser.add_argument("-n", action="store_true", dest="nervous", default=False,
#                         help="Nervous mode, if set then do nothing but report. [default: %(default)s]")
#     parser.add_argument(type=str,
#                         dest="input",
#                         help="Input directory. [default: %(default)s]")
#     parser.add_argument(type=str,
#                         dest="output",
#                         default="",
#                         help="Output directory. [default: %(default)s]")
#     logFormat = '%(asctime)s %(levelname)-8s %(message)s'
    parser.add_argument('-s', '--style', choices=output_styles, default='decl')
    args = parser.parse_args()
#     print(' ARGS '.center(75, '-'))
#     print(args)
#     print(' END: ARGS '.center(75, '-'))
#     exit()
#     logging.basicConfig(level=args.loglevel, format=logFormat, stream=sys.stdout)
    # datefmt='%y-%m-%d % %H:%M:%S',                    
#     clkStart = time.clock()
#     print('CPU time = %8.3f (S)' % clkExec)

    sys.path.append(os.path.dirname(args.module))
    module_name = os.path.splitext(os.path.basename(args.module))[0]
    module = importlib.import_module(module_name)
    print('// Auto generated documentation strings')
    print('//       Module: {}'.format(module_name))
#     print('//  Module path: {}'.format(module.__file__))
    print('// Generated by: {}'.format(__file__))
    print('// Generated on: {}'.format(datetime.datetime.now().strftime('%c')))
    print('//        Style: {}'.format(args.style))
    print()
    if args.style == 'decl':
        # Header guards
        print('#ifndef {}_{}_h'.format(DOCSTRING_VARIBLE_PREFIX, module_name))
        print('#define {}_{}_h'.format(DOCSTRING_VARIBLE_PREFIX, module_name))
        print()
    doc_count = 0
    doc = getattr(module, '__doc__', None)
    if doc is not None:
        print_doc(doc, args.style, module_name)
        doc_count += 1
    doc_count += print_member_doc(module_name, module, args.style)
    if args.style == 'decl':
        # Close header guards
        print()
        print('#endif // {}_{}_h'.format(DOCSTRING_VARIBLE_PREFIX, module_name))
    print()
    print('// Completed {:d} documentation strings from module {}'.format(doc_count, module_name))
    return 0


if __name__ == '__main__':
    sys.exit(main())
